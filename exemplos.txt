ğŸ”¹ ExercÃ­cio 1 â€“ Classe Abstrata (Sistema de veÃ­culos)

ğŸ“– Enunciado:
Implemente uma classe abstrata Veiculo com o mÃ©todo abstrato velocidade_maxima().
Crie as classes Carro (velocidade 180 km/h) e Moto (velocidade 120 km/h).
Depois, instancie os objetos e exiba a velocidade mÃ¡xima de cada um.


from abc import ABC, abstractmethod

class Veiculo(ABC):
    @abstractmethod
    def velocidade_maxima(self):
        pass

class Carro(Veiculo):
    def velocidade_maxima(self):
        return 180

class Moto(Veiculo):
    def velocidade_maxima(self):
        return 120

# Testando
c = Carro()
m = Moto()
print("Carro:", c.velocidade_maxima(), "km/h")
print("Moto:", m.velocidade_maxima(), "km/h")


ğŸ”¹ ExercÃ­cio 2 â€“ Decorator (Controle de acesso)

ğŸ“– Enunciado:
Crie um decorator admin_only que permita executar uma funÃ§Ã£o apenas se o usuÃ¡rio for administrador.
Aplique-o em uma funÃ§Ã£o deletar_usuario().

âœ… Resposta:

def admin_only(func):
    def wrapper(usuario, *args, **kwargs):
        if not usuario.get("admin", False):
            print("Acesso negado! Apenas administradores.")
            return None
        return func(usuario, *args, **kwargs)
    return wrapper

@admin_only
def deletar_usuario(usuario):
    print(f"UsuÃ¡rio deletado por {usuario['nome']}.")

# Testando
user1 = {"nome": "Isa", "admin": True}
user2 = {"nome": "Pedro", "admin": False}

deletar_usuario(user1)  # permitido
deletar_usuario(user2)  # negado

ğŸ”¹ ExercÃ­cio 3 â€“ Pytest (FunÃ§Ã£o de potÃªncia)

ğŸ“– Enunciado:
Implemente uma funÃ§Ã£o potencia(base, exp) que retorna base ** exp.
Escreva 3 testes no pytest:

Verificar se potencia(2, 3) == 8.

Verificar se potencia(5, 0) == 1.

Verificar se potencia(10, 1) == 10.

âœ… Resposta (test_potencia.py):

def potencia(base, exp):
    return base ** exp

def test_potencia_normal():
    assert potencia(2, 3) == 8

def test_potencia_zero():
    assert potencia(5, 0) == 1

def test_potencia_um():
    assert potencia(10, 1) == 10

ğŸ”¹ ExercÃ­cio 4 â€“ Classe Abstrata + Decorator (RelatÃ³rios)

ğŸ“– Enunciado:
Crie uma classe abstrata Relatorio com o mÃ©todo abstrato gerar().
Implemente duas subclasses: RelatorioPDF e RelatorioExcel.
Use um decorator log_execucao que imprime "Gerando relatÃ³rio..." antes da execuÃ§Ã£o e "RelatÃ³rio pronto!" depois.

âœ… Resposta:

from abc import ABC, abstractmethod

def log_execucao(func):
    def wrapper(*args, **kwargs):
        print("Gerando relatÃ³rio...")
        resultado = func(*args, **kwargs)
        print("RelatÃ³rio pronto!")
        return resultado
    return wrapper

class Relatorio(ABC):
    @abstractmethod
    def gerar(self):
        pass

class RelatorioPDF(Relatorio):
    @log_execucao
    def gerar(self):
        print("RelatÃ³rio em PDF gerado.")

class RelatorioExcel(Relatorio):
    @log_execucao
    def gerar(self):
        print("RelatÃ³rio em Excel gerado.")

# Testando
pdf = RelatorioPDF()
excel = RelatorioExcel()
pdf.gerar()
excel.gerar()

ğŸ”¹ ExercÃ­cio 5 â€“ Pytest + Erros (ValidaÃ§Ã£o de idade)

ğŸ“– Enunciado:
Crie uma funÃ§Ã£o validar_idade(idade) que:

Retorna "Maior de idade" se idade >= 18.

Retorna "Menor de idade" se idade < 18.

LanÃ§a ValueError se idade < 0.

Escreva 3 testes no pytest.

âœ… Resposta (test_idade.py):

def validar_idade(idade):
    if idade < 0:
        raise ValueError("Idade invÃ¡lida")
    return "Maior de idade" if idade >= 18 else "Menor de idade"

def test_maior():
    assert validar_idade(20) == "Maior de idade"

def test_menor():
    assert validar_idade(15) == "Menor de idade"

import pytest
def test_idade_invalida():
    with pytest.raises(ValueError):
        validar_idade(-5)



